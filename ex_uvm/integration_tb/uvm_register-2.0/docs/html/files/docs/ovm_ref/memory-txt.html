<html><head><title>Overview</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="Overview" href="../../../../uvm_ref/memory.txt">Overview</a></h1><div class=CBody><p>The UVM memory API can be used where an uvm_register can be used, and has the same API.&nbsp; A memory can be read or written.&nbsp; The memory is implemented using a sparse area, and so will be space efficient even for large address spaces, if the access to the memory is sparse.</p><p>The UVM Memory support big or little endian memory, and has available access routines either on the memory or on a containing address map</p><p>Sample usage: (See 09_memory_simple for the complete example)</p><blockquote><pre>task test1();
  bytearray_t ba = '{1, 2, 3, 4, 5, 6, 7};
  rm.poke_bytes(address, ba);
  m_little.bus_read(ba, address);
  rm.bus_read(ba, address);
  read_ba = rm.peek_bytes(address, ba.size());
endtask</pre></blockquote><h4 class=CHeading>Register Definition</h4><blockquote><pre>class my_memory_little extends uvm_memory#(bit[31:0]);
  function new(string name, uvm_component p,
      bit [31:0] l_resetValue = 0);
    super.new(name, p, l_resetValue);
  endfunction
endclass

class my_memory_big extends uvm_memory#(bit[0:31]);
  function new(string name, uvm_component p,
      bit [0:31] l_resetValue = 0);
    super.new(name, p, l_resetValue);
  endfunction
endclass

class device2_rf extends my_device;
  rand my_memory_little    mem_little;
  rand my_memory_big       mem_big;

  function new(string name, uvm_component p);
    super.new(name, p);

    mem_little = new(&quot;mem_little&quot;,  this, 'h12345678);
    mem_big    = new(&quot;mem_big&quot;,     this, 'h12345678);

    // --------------------------------------
    // Add the registers to the register file
    // --------------------------------------
    add_memory(mem_little.get_fullname(),
      'h10000, 'h80000, mem_little);
    add_memory(mem_big.get_fullname(),
      'h90000, 'ha0000, mem_big);
  endfunction
endclass</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>